linux handbook 
phoenixap.com//kb/bash-printf -- printf
baeldung.com/linux/bash-single-vs-double-brackets
10.50.26.116
regex101

touch to make a file
touch -t alter the time 
chmod 777
ls -1 shows just the names of all the files
  Command (find / -option)
find -name hi.txt)) finds file by name
find -iname ))) finds file by name regardless of capitalization 
find -inum ))) finds file based off of inode number
find -size ))) finds files based on size
find -gid ))) finds files based on group id
find -uid ))) finds files based on used id
find -maxdepth ))) defines maximum directories deep to go
find -type d ))) directories) -f -- files) -p -- name pipes
find -name \*.txt
find -atime 3) anything accessed in the last three days
find -ctime 3) changed in last three days
find -mtime 3) modified last three days
find -amin 180) accessed last three hours
  each ()time has a min equivelant ()time is days ()min is minutes
  sudo !! runs previously used command as root
find -exec -- use linux handbook to understand further
find -perm /4000 -uid 0 -ls 2>/dev/null
  2>/dev/null get rid of the things that dont fit the search
  -printf is like .format(choose for example to only show the name)
find -perm /4000 -uid 0 -ls 2>/dev/null -printf "%i %f\n"
  %i is the inode and %f is the file \n is new line
find -empty) looks for any files or directories that are empty

  Command (grep)
grep -E//egrep is extended grep 
grep -i case insensitive
grep -n shows lines
grep -v inverts search
  cat fake1passwd.txt | grep /bin/bash
accounts with that directory
  egrep "student|root|bob" fake1passwd.txt
shows those accounts, bob doesnt exist
  cat  fake1passwd.txt | grep -v /bin/bash
shows everything without bin/bash

kill) kills by PID
pkill)kills by name

cat fake1passwd.txt | cut -d: -f1 -s
                      cut -d(delimeter) : (colon is delemiter) -f1(field one is being cut)
                              -f1- will print everything after cut
                                  -s(strict will not print anything in the cut)

Command(awk)

awk -F: '{print $1}'  -- print first field  
awk -F: '{print $NF}'  --  last field of everyline
awk -F: '{$3 == 0} {print $1}' if field 3 is equal to 0 print field 1
awk -F: 'BEGIN {OFS = "@"} {print $1, $3}' output field seperator is @ print fields 1 and 3
awk -F: '($3 >= 150){print $0}' if field 3 greater than or equal to 150 print (whole line?)
awk -F: '($7 == "/bin/bash"){print $1, $6, $3}' if field seven has this string print these fields


Command (sort)

****pipe another command into sort. sort is dumb and needs another command giving it input****
sort) ascii order
sort -r) is reversed
sort -n) sorts numericallly
sort -nr) reverse numeric
sort -t) tells sort the file is formatted wih columns
sort -t : -k 1,4) sort by columns 1 and 4
sort -t : -k 1,4 | uniq) sorts for inuque could also just use -u instead of pipe into uniq 


Command(sed)

            chicken->hamburger
sed -e 's/chicken/hamburger/g' -e 's/pepperoni/sausage/' pizza.txt )) peperoni only changes the first instance because it doesnt have g
        start               globally      peperoni-> sausage
sed -e '/chicken/d' pizza.txt )) deletes every line with chicken(entire line)


command substitution
nano to make a script. use #! line and enter code you want easy access to.

Making an alias
alias (name) = command





& and(background)
&& logical and
|| logical or
| break
! not
"" look at first
> create/overrite
>> create/append



examples
find files with .txt but no ~
  find $HOME/1123/ -name *.txt ! -name *~* -exec cp {} $HOME/CUT
finding with inode, remove unwanted
  find / -inum 4026532575 -printf "%f\n" 2>/dev/null









